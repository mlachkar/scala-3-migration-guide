---
id: cross-build
title: Cross-building
---
Library authors are likely to want their library compatible with Scala 3 and Scala 2, so that it can continuously evolve without frustrating anyone. Cross-building has been the best solution so far to do so.

## How to cross-build your library with Dotty

This section lists incompatibilities between Scala 3 and Scala 2, and solutions for cross-compiling the source code.

### The extractor `unapply` for case classes doesn’t return an `Option` anymore

In Scala, case classes have an associated extractor operation generated by the compiler in their companion object. Their signature is different in Scala 2 and Scala 3. This can cause incompatibilities if your code relies on the signature of the `unapply` operation produced by a specific version of the compiler. Note that this problem does not affect user-defined extractors, whose signature stays the same across Scala versions.

Given the following case class definition:

~~~ scala
case class Location(lat: Double, long: Double)
~~~

The Scala 2 compiler produces the following `unapply` method:

~~~ scala
object Location {
  def unapply(location: Location): Option[(Double, Double)] = Some((location.lat, location.long))
}
~~~

Whereas the Scala 3 compiler produces the following `unapply` method:

~~~ scala
object User {
  def unapply(location: Location): Location = location
}
~~~

The operation `unapply` is used under the hood by pattern matching. This usage remains cross-compatible between Scala 2 and Scala 3.

However, if your code explicitly calls the `unapply` operation it has to be adapted. A common situation where `unapply` is explicitly called is serialization/deserialization. For instance, consider the following JSON encoder, taken from the documentation of [Play framework](https://www.playframework.com/documentation/2.8.x/ScalaJsonCombinators#Writes):

~~~ scala
implicit val locationWrites: Writes[Location] = (
  (JsPath \ "lat").write[Double] and
    (JsPath \ "long").write[Double]
)(unlift(Location.unapply)) // Error with Scala 3
~~~

This code doesn’t compile with Scala 3. A solution to make it compile is to inline the implementation of the Scala 2 `unapply` operation:

~~~ scala
implicit val locationWrites: Writes[Location] = (
  (JsPath \ "lat").write[Double] and
    (JsPath \ "long").write[Double]
)(location => (location.lat, location.long)) // Compiles with both Scala 2 and Scala 3
~~~

### Unreducible application of higher-kinded type to wildcard arguments

This error happens when you apply the “wildcard” type to a higher-kinded type.

Consider the following example:

~~~ scala
trait Example {

  type Foo[A]

  def f(foo: Foo[_]): Unit // Error with Scala 3

  def g(foos: Seq[Foo[_]]): Unit // Error with Scala 3

}
~~~

It compiles with Scala 2, but Scala 3 produces the following errors:

~~~
[error] -- [E043] Type Error:
[error] 5 |  def f(foo: Foo[_]): Unit // Error with Scala 3
[error]   |             ^^^^^^
[error]   |unreducible application of higher-kinded type Example.this.Foo to wildcard arguments
[error] -- [E043] Type Error:
[error] 6 |  def g(foos: Seq[Foo[_]]): Unit // Error with Scala 3
[error]   |                  ^^^^^^
[error]   |unreducible application of higher-kinded type Example.this.Foo to wildcard arguments
~~~

The reason for this error is that the type `Foo[_]` involves existential type quantification and this feature [has been removed from Scala 3](https://dotty.epfl.ch/docs/reference/dropped-features/existential-types.html).

Two solutions can be considered for cross-compiling.

In the case of the function `f`, we can change its signature to take a type parameter:

~~~ scala
  def f[A](foo: Foo[A]): Unit // Compiles with both Scala 2 and Scala 3
~~~

The second function, `g`, requires more work. We want to accept collections containing
values of type `Foo[A]` with possibly different types for the parameter `A`. To achieve
this, we create a wrapper class. The fact that the wrapper is a class and not an abstract
type member makes it possible to apply a wildcard type argument to it:

~~~ scala
  // Wrapper class
  class FooWrapper[A](val value: Foo[A])

  def g(foos: Seq[FooWrapper[_]]): Unit // Compiles with both Scala 2 and Scala 3
~~~

Users will have to explicitly wrap their `Foo` values into the `FooWrapper` class.

### Other incompatibilities

[Contributors Welcome!](contributing.md)

## Additional Resources

- [Sbt Reference Manual](https://www.scala-sbt.org/1.x/docs/Cross-Build.html)
- [Dotty Getting Started](https://dotty.epfl.ch/docs/usage/getting-started.html)
- [Scala Blog Post: The Road to Scala 3](https://www.scala-lang.org/2019/12/18/road-to-scala-3.html#how-can-i-contribute)
